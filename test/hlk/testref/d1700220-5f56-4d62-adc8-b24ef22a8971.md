---
title: WGF11 Rasterizer (WoW64) 
Description: WGF11 Rasterizer (WoW64) 
ms.assetid: 21d56fb1-ed31-42df-ae8d-632e56783449
author: sapaetsc-msft
ms.author: sapaetsc
ms.date: 08/28/17
ms.topic: article
ms.prod: windows-hardware
ms.technology: windows-oem
---

# WGF11 Rasterizer (WoW64) 

<conditional_block> <conditions> <docset value="standalone"></docset> </conditions>

>[!NOTE]
You can find the latest version of this test documentation on MSDN at the following link:

-   <xref hlink="http://msdn.microsoft.com/en-us/library/windows/hardware/21d56fb1-ed31-42df-ae8d-632e56783449">http://msdn.microsoft.com/en-us/library/windows/hardware/21d56fb1-ed31-42df-ae8d-632e56783449</b>


</conditional_block>

This automated test verifies various aspects of the D3D primitive rasterizer and rasterizer state as implemented by hardware.

This topic applies to the following test jobs:

-   WGF11 Rasterizer

-   WGF11 Rasterizer (WoW64)

## Test details

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><mark type="bullet_intro">Specifications</b></td>
<td><ul>
<li>Device.Graphics.AdapterRender.D3D111Core.D3D111CorePrimary</li>
<li>Device.Graphics.AdapterRender.D3D11Core.D3D11CorePrimary</li>
<li>Device.Graphics.AdapterRender.D3D101Core.D3D101CorePrimary</li>
<li>Device.Graphics.AdapterRender.D3D10Core.D3D10CorePrimary</li>
</ul></td>
</tr>
<tr class="even">
<td><mark type="bullet_intro">Platforms</b></td>
<td><ul>
<li><tla rid="win_threshold_desktop"></tla> x64</li>
<li><tla rid="win_threshold_server"></tla> x64</li>
<li><tla rid="win_threshold_desktop"></tla> ARM64</li>
</ul></td>
</tr>
<tr class="odd">
<td><mark type="bullet_intro">Supported Releases</b></td>
<td><ul>
<li><tla rid="win_10"></tla></li>
<li><tla rid="win_10_th2"></tla></li>
<li><tla rid="win_10_rs1"></tla></li>
<li>Windows 10, version 1703</li>
<li>Windows 10, version 1709</li>
</ul></td>
</tr>
<tr class="even">
<td><mark type="bullet_intro">Expected run time (in minutes)</b></td>
<td>2</td>
</tr>
<tr class="odd">
<td><mark type="bullet_intro">Category</b></td>
<td>Compatibility</td>
</tr>
<tr class="even">
<td><mark type="bullet_intro">Timeout (in minutes)</b></td>
<td>2</td>
</tr>
<tr class="odd">
<td><mark type="bullet_intro">Requires reboot</b></td>
<td>false</td>
</tr>
<tr class="even">
<td><mark type="bullet_intro">Requires special configuration</b></td>
<td>false</td>
</tr>
<tr class="odd">
<td><mark type="bullet_intro">Type</b></td>
<td>automatic</td>
</tr>
</tbody>
</table>

## Additional documentation

Tests in this feature area might have additional documentation, including prerequisites, setup, and troubleshooting information, that can be found in the following topic(s):

-   <xref rid="p_hlk_test.device_graphics_additional_documentation">Device.Graphics additional documentation</b>

## Running the test

Before you run the test, complete the test setup as described in the test requirements: <xref rid="p_hlk_test.graphic_adapter_or_chipset_testing_prerequisites">Graphic Adapter or Chipset Testing Prerequisites</b>.

## Troubleshooting

For generic troubleshooting of HLK test failures, see <xref rid="p_hlk.troubleshooting_windows_hlk_test_failures">Troubleshooting Windows HLK Test Failures</b>.

For troubleshooting information, see <xref rid="p_hlk_test.troubleshooting_devicegraphics_testing">Troubleshooting Device.Graphics Testing</b>.

All test cases return PASS or FAIL. Review the test results in the log file for specific details about failures. The test might return SKIP if it is run with a feature level that doesn't support the feature being tested. The test might return BLOCKED if there is an uncaught exception (framework catches it at the end and logs it).

## More information

For D3D10 and above, this test verifies the following:

-   Primitive culling, fill mode, and winding order based on the rasterizer state.

-   Interpolation modes in the pixel shader

    -   Constant mode is simple, because there is no change from the values sent from the vertex shader.

    -   Because it is not tightly spec'd, linear modes are verified by ensuring that adjacent pixels are not equal and follow the gradient of an edge.

-   Sample frequency pixel shader invocation (D3D10.1 and above).

**For D3D11, this test verifies pull model attribute evaluation.**

The following intrinsic functions will be introduced into D3D11 (HLSL 5.0) for the feature of pull-model attribute evaluation:

-   EvaluateAttributeSnapped( attrib numeric value, int2 pixeloffset )

-   EvaluateAttributeAtSample( attrib numeric value, uint sampleindex )

-   EvaluateAttributeAtCentroid( attrib numeric value )

For each intrinsic function, a set of pixel shaders will be generated, targeting the cases on different combinations of the parameter values of the intrinsic function and the declared interpolation modes of the input attributes.

The following are test factors for all three intrinsics:

-   Input attributes passed from the Vertex shader.

    >[!NOTE]
    Only float type attribute can be interpolated; int/uint type will always be constant interpolation mode

    
    -   float4 texCoord : TEXCOORD

    -   float4 color : COLOR

    -   float clipDis : SV\_ClipDistance

-   Declarations of interpolation modes.

    >[!NOTE]
    Nointerpolation mode is not allowed by the HLSL compiler when the corresponding attribute is evaluated with pull-model in the shader.

    
    -   linear

    -   linear noPerspective

    -   linear centroid

    -   linear sample

    -   linear noPerspective centroid

    -   linear noPerspective sample

-   Primitives to draw:

    -   When the interpolation mode is linear, a triangle C1-C2-C3 as follows will be drawn. This covers one whole pixel and two half pixels. The coordinates of the vertices in projection space are as the following:

        &lt;need image here

        C1: (-1, 1, 0), C2(-1, -1, 0), C3(1, 1, 0).

        Right triangle within a square, with vertices C1, C2, and C3; C1 forms the 90-degree angle and is at the upper-left corner of the square

-   When the interpolation mode is noperspective, a triangle A-B-C with the following vertex coordinates in the projection space will be drawn:

    A:(-1, 1, 1);

    B:(-1, -1, 0);

    C:(1, 1, 1)

    The screen space triangle should cover the same pixels and pixel areas as triangle C1-C2-C3 shown above.

-   Render target

    -   Format: All formats supporting render target.

    -   Sample count: 1, 2, ... the maximum supported sample count.

**Different values of pixeloffset for EvaluateAttributeSnapped( )**

Ideally, all possible 256 offset positions. If the test runs too long, this group of test cases will be reduced to 4 corner positions, 8 border positions, 4 positions from 4x4 grid, 4 positions from 8x8 grid, and 4 positions from 16x16 grid.

**Different values of sampleindex for EvaluateAttributeAtSample( )**

All sample indices supported by the render target

The verification method begins when the pixel shader writes the interpolated attribute value to the render target. The render target data is then mapped and read out. In cases of multisampled render targets, multisample resolve is required before mapping. The result data will be compared with pre-calculated interpolated data or data got from direct accessing the attribute.

1.  When interpolation mode is linear noperspective:

    1.  Calculate and store the interpolated (and extrapolated for uncovered area of p2 and p3) values for 256 offset positions of each pixels of p1, p2, p3.

    2.  For EvaluateAttributeSnapped :

        -   Pixel p1 should have "pulled " attribute value in between of the expected values for left and right (as well as upper and lower) neighboring offsets of the "pulled" offset.

        -   Pixels p2 and p3:

            In single-sampled cases, they should not be rendered.

            In multi-sampled cases, they should have "pulled" attribute value in between of the expected values for left and right (as well as upper and lower) neighboring offsets of the "pulled" offset.

    3.  For EvaluateAttributeAtSample with SampleFinder, find the position of the sample index on the sample coordinate system with range \[-8, 7\]. Use this position to do the verification the same way as in EvaluateAttributeSnapped above.

    4.  For EvaluateAttributeAtCentroid, draw triangle C1-C2-C3 with SV\_COVERAGE to find out the first covered sample, which is the centroid position defined by the Shader Model 5.0. Use the sample index for centoid to do the verification the same way as in EvaluateAttributeAtSample above.

2.  When interpolation mode is linear:

    1.  Calculate and store the interpolated (and extrapolated for uncovered area of p2 and p3) values for 256 offset positions of each pixels, using perspective correct interpolation. Interpolate the attribute values that have been divided by the respective depth value, then divide the interpolated attribute value by the interpolated reciprocal of the depth.

    2.  For EvaluateAttributeSnapped(), use the same verification as 2.a.

    3.  For EvaluateAttributeAtCentroid(), use the same verification as 2.c.

    4.  For EvaluateAttributeAtSample(), use the same verification as 2.b.

3.  Use PSInvocation to verify the number of PS invocations for all test cases.

    1.  If any attribute has sample interpolation mode or SV\_SAMPLEINDEX is declared, and the sample count is larger than 1, PSInvocation should be 3\*(sample count).

    2.  When the sample count is 1, PSInvocation should be 1.

## Command syntax

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Command option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>Wgf11rasterizer</strong></p></td>
<td><p>Runs the test jobs. Without any options, the test enumerates devices.</p></td>
</tr>
<tr class="even">
<td><p><strong>-FeatureLevel:XX.X</strong></p></td>
<td><p>Sets the feauture level, where XX.X is the Feature Level the test will run at: 10.0, 10.1, or 11.0.</p></td>
</tr>
</tbody>
</table>

>[!NOTE]
For command line help for this test binary, type **/?**.


## File list

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Location</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Configdisplay.exe</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\tools\</p></td>
</tr>
<tr class="even">
<td><p>D3d11_1sdklayers.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support\</p></td>
</tr>
<tr class="odd">
<td><p>D3d11ref.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support\</p></td>
</tr>
<tr class="even">
<td><p>D3d11sdklayers.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support\</p></td>
</tr>
<tr class="odd">
<td><p>D3dcompiler_test.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support</p></td>
</tr>
<tr class="even">
<td><p>D3dx10_test.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support\</p></td>
</tr>
<tr class="odd">
<td><p>d3dx11_test.dll</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\support\</p></td>
</tr>
<tr class="even">
<td><p>TDRWatch.exe</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\</p></td>
</tr>
<tr class="odd">
<td><p>Wgf11rasterizer.exe</p></td>
<td><p><placeholder>&lt;[testbinroot]&gt;</placeholder>\nttest\windowstest\graphics\d3d\conf</p></td>
</tr>
</tbody>
</table>

## Parameters

| Parameter name                                         | Parameter description                                 |
|--------------------------------------------------------|-------------------------------------------------------|
| <mark type="bullet_intro">MODIFIEDCMDLINE</b>          | Additional command line arguments for test executable |
| <mark type="bullet_intro">LLU\_NetAccessOnly</b>       | LLU Name of net user                                  |
| <mark type="bullet_intro">ConfigDisplayCommandLine</b> | Custom Command Line for ConfigDisplay. Default: logo  |
| <mark type="bullet_intro">TDRArgs</b>                  | /get or /set                                          |





