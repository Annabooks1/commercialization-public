---
title: HealthAttestation CSP
description: HealthAttestation CSP
MSHAttr:
- 'PreferredSiteName:MSDN'
- 'PreferredLib:/library/windows/hardware'
ms.assetid: 6F2D783C-F6B4-4A81-B9A2-522C4661D1AC
---

# HealthAttestation CSP


The HealthAttestation configuration service provider enables enterprise IT managers to assess the health of managed devices and take enterprise policy actions.

The following is a list of functions performed by the HealthAttestation CSP:

-   Collects data that is used in verifying a devices health states
-   Forwards the data to the Health Attestation Service (HAS)
-   Provisions the Health Attestation Certificate that it receives from HAS
-   Upon request, forwards the Health Attestation Certificate (received from HAS) and related runtime information to the MDM Server for verification

The following diagram shows the HealthAttestation configuration service provider in tree format.

![healthattestation csp](images/provisioning-csp-healthattestation.png)

<a href="" id="--vendor-msft"></a>**./Vendor/MSFT**  
The root node for the HealthAttestation configuration service provider.

<a href="" id="verifyhealth--required-"></a>**VerifyHealth** (Required)  
Notifies the device to prepare a health certificate verification request.

The supported operation is Execute.

<a href="" id="status--required-"></a>**Status** (Required)  
Provides the current status of the health request.

The supported operation is Get.

The following list shows the supported values:

-   1 – HEALTHATTESTATION\_CERT\_RETRI\_UNINITIALIZED Preparing a request to get a new health certificate from the Health Attestation Service (HAS).
-   2 – HEALTHATTESTATION\_CERT\_RETRI\_REQUESTED Waiting for the Health Attestation Service (HAS) to respond back.
-   3 – HEALTHATTESTATION\_CERT\_RETRI\_COMPLETE Health data is ready for pick up.

<a href="" id="forceretrieve--optional-"></a>**ForceRetrieve** (Optional)  
Instructs the client to initiate a new request to Health certificate from Health Attestation Service (HAS) and get a new health certificate. This option should be used if the MDM server enforces a certificate freshness policy. In addition, you need a certificate that is created at the verification request time.

The supported operation is Replace.

<a href="" id="certificate--required-"></a>**Certificate** (Required)  
Instructs the Health CSP to forward Health certificate data that is packaged with the nonce and related health data (Current PCR values) to the MDM server in an encrypted format.

The supported operation is Get.

<a href="" id="nonce--required-"></a>**Nonce** (Required)  
Protects the health attestation communication with a cryptographic nonce that is generated by the MDM Server.

The nonce is in hex format, with a minimum size of 8 bytes, and a maximum size of 32 bytes.

The supported operation is Replace.

<a href="" id="correlationid--required-"></a>**CorrelationId** (Required)  
CorrelationID is a decimal value that identifies a call for a health certificate. Can be used to correlate Health Attestation Server (HAS) logs with the MDM event server and Client event logs for debugging, audit, or troubleshooting.

The supported operation is Get.

## **Integrating Health Attestation**


In order to integrate Health Attestation into your environment, you need to complete the following steps:

1.  [Verify HTTPS access](#verify-access)
2.  [Instruct client to prepare health data for verification](#prepare-health-data)
3.  [Take action based on the clients response](#take-action-client-response)
4.  [Instruct the client to forward health attestation data for verification](#forward-health-attestation)
5.  [Forward health attestation data to Health Attestation Service (HAS)](#foward-data-to-has)
6.  [Receive response from HAS](#receive-has-response)
7.  [Take appropriate policy action based on evaluation results](#take-policy-action)

Each step is described in detail in the following sections of this topic.

## <a href="" id="verify-access"></a>**Verify HTTPS access**


Validate that both the MDM server and the device (MDM client) can access **has.spserv.microsoft.com** using the TCP protocol using port 443 (HTTPS).

## <a href="" id="prepare-health-data"></a>**Instruct client to prepare health data for verification**


After access is verified, issue a SyncML atomic call to start collection of the health data.

The following example shows a sample atomic call that triggers collection and verification of health attestation data from a managed device.

``` syntax
<SyncML xmlns="SYNCML: SYNCML1.2">

    // Header starts here 
    <SyncHdr>
        <VerDTD> 1.2 </VerDTD>
        <VerProto> DM/1.2 </VerProto>
        <SessionID> [Session ID] </SessionID>
        <MsgID> [Message ID] </MsgID>
        <Target>
            <LocURI> ./Vendor/MSFT/HealthAttestation/Certificate 
        </LocURI>
        </Target>
        <Source>
            <LocURI> [URL of MDM Server] </LocURI>
        </Source>
    </SyncHdr>

    // Body starts here 
    <SyncBody>
    
    //Start an atomic call
        <Atomic>
            <CmdID> [Command ID] </CmdID>

            //The first item is an optional call.
            //"ForceRetrieve" node instructs the client to
            //initiate a new request to Health certificate from 
            //Health Attestation Service (HAS), get a new health
            //certificate. This option should be used if MDM 
            //server enforces a certificate freshness policy, 
            //requires a certificate that is created at 
            //verification request time.  
            <Set>
                <CmdID> [Command ID] </CmdID>
                <Item>
                    <Target>
                      <LocURI>
                  ./Vendor/MSFT/HealthAttestation/ForceRetrieve
                      </LocURI>
                    </Target>
                </Item>
            </Set>

            //Tell the device to create an encrypted payload that
            //contains health attestation related data  
            <Exec>
                <CmdID> [Command ID] </CmdID>
                <Item>
                    <Target>
                      <LocURI> 
                ./Vendor/MSFT/HealthAttestation/VerifyHealth
       </LocURI>
                    </Target>
                </Item>
            </Exec>

            //Forward a cryptographic strong nonce to the client
            //The nonce must be a hexadecimal string that is
            //between 8 and 32 bytes
            <Set>
                <CmdID> [Command ID] </CmdID>
                <Item>
                    <Target>
                      <LocURI> ./Vendor/MSFT/HealthAttestation/Nonce
                      </LocURI>
                    </Target>
                    <Data> [hexadecimal string] </Data>
                </Item>
            </Set>

            //Ask for status
            <Get>
                <CmdID> [Command ID] </CmdID>
                <Item>    
                    <Target>
                      <LocURI> 
              ./Vendor/MSFT/HealthAttestation/Status
                      </LocURI>
                    </Target>
                </Item>
            </Get>
        </Atomic>
    </SyncBody>   
</SyncML>
```

## <a href="" id="take-action-client-response"></a>**Take action based on the clients response**


After the client receives the health attestation request, it will send a response. The following list describes the responses, along with a recommended action to take:

-   If the response to any of the nodes that are called is "Failed", take appropriate corrective action, and then resubmit the request.
-   If the response is **HEALTHATTESTATION\_CERT\_RETRI\_REQUESTED (1)** or **HEALTHATTESTATION\_CERT\_RETRI\_UNINITIALIZED (0)** wait for an alert (a client initiated request that tells the MDM server the health data is packaged and ready for pick up, then proceed to the next section.)
-   If the response is **HEALTHATTESTATION\_CERT\_RETRI\_COMPLETE(3)** then proceed to the next section.

## <a href="" id="forward-health-attestation"></a>**Instruct the client to forward health attestation data for verification**


Next, the health attestation data must be forwarded so that the data can be verified. To do so, create an atomic call to the Certificate and CallIdentifier nodes, pick up an encrypted payload that includes a health certificate and related data from the device.

The following example shows a sample atomic call:

``` syntax
<SyncML xmlns="SYNCML: SYNCML1.2">

    // Header Starts here 
    <SyncHdr>
        <VerDTD> 1.2 </VerDTD>
        <VerProto> DM/1.2 </VerProto>
        <SessionID> [Session ID] </SessionID>
        <MsgID> [Message ID] </MsgID>
        <Target>
            <LocURI>./Vendor/MSFT/HealthAttestation/Certificate
            </LocURI>
        </Target>
        <Source>
            <LocURI> [URL of MDM Server] </LocURI>
        </Source>
    </SyncHdr>

    // Body Starts here 
    <SyncBody>
    
    //Start an atomic call
        <Atomic>

            //Call Health CSP to get the packaged data and 
            //call identifier 
            <CmdID> [Command ID] </CmdID>

            //Get the packaged data
            <Get>
                <CmdID> [Command ID] </CmdID>
                <Item>    
                    <Target>
                   <LocURI>
                    ./Vendor/MSFT/HealthAttestation/Certificate
                    </LocURI>
                    </Target>
                </Item>
            </Get>
    
            //Get the health attestation call identifier 
            <Get>
                <CmdID> [Command ID] </CmdID>
                <Item>    
                    <Target>
                      <LocURI>
                      ./Vendor/MSFT/HealthAttestation/CorrelationId
                      </LocURI>
                    </Target>
                </Item>
            </Get>
        </Atomic>
    </SyncBody>   

</SyncML>
```

## <a href="" id="foward-data-to-has"></a>**Forward health attestation data to Health Attestation Service (HAS)**


In response to the request that was sent in previous step, the MDM client forwards an XML formatted blob and a call identifier in the following format.

``` syntax
<?xml version="1.0" encoding="utf-8"?>
<HealthCertificateValidationRequest ProtocolVersion="1" 
    xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1">
    <Claims> [base64 blob, eg ‘ABc123+/…==’] </Claims>
    <HealthCertificateBlob> [base64 blob, eg ‘ABc123+/...==’]
    </HealthCertificateBlob>
</HealthCertificateValidationRequest>
```

When the MDM server receives the above data, it must log the call identifier (for future reference), correlated to the call. Add the nonce that was generated in the XML blob it has received from the client - and then forward (HTTP Post) the data in following format to the Health Attestation Service (HAS)

``` syntax
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs=http://www.w3.org/2001/XMLSchema
xmlns=http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1  targetNamespace=http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1  elementFormDefault="qualified">
<xs:element name="HealthCertificateValidationRequest" type="HealthCertificateValidationRequest_T"/>
  <xs:complexType name="HealthCertificateValidationRequest_T">
    <xs:annotation>
      <xs:documentation> A request for Health Certificate 
   validation </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Nonce" type="xs:hexBinary"/>
      <xs:element name="Claims" type="xs:base64Binary"/>
      <xs:element name="HealthCertificateBlob" 
    type="xs:base64Binary"/>
    </xs:sequence>
    <xs:attribute name="ProtocolVersion" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:int">
          <xs:minInclusive value="1"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
</xs:schema>
```

## <a href="" id="receive-has-response"></a>**Receive response from the HAS**


When the Health Attestation Service receives a request for verification, it performs the following steps:

-   Decrypts the encrypted data it receives.
-   Validates the health data.
-   Verifies that is not a repeat request by checking the nonce that is embedded in the encrypted blob, against the nonce that it receives from the MDM server.
-   Creates a report in XML format, and forwards the evaluation results to the MDM server in the following format.

    ``` syntax
    <?xml version=\"1.0\"?>

    <HealthCertificateValidationResponse 
       xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" 
       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 
       ErrorCode=\"0\" 
       xmlns=\"http://schemas.microsoft.com/windows/security/healthcertificate/validation/response/v1\">
        <HealthCertificateProperties>

            <Issued> 
                2015-02-23T17:43:27.5229876Z 
            </Issued>

            <AIKPresent>
                False
            </AIKPresent>

            <ResetCount>
                [INT]
            </ResetCount>

            <RestartCount> 
                [INT]
            </RestartCount>

            <DEPPolicy>
                [Boolean - 0, 1]
            </DEPPolicy>

            <BitlockerStatus> 
                [Boolean - 0, 1] 
            </BitlockerStatus>

            <BootManagerRevListVersion>
                [INT]
            </BootManagerRevListVersion>

            <CodeIntegrityRevListVersion>
                [INT] 
            </CodeIntegrityRevListVersion>

            <SecureBootEnabled> 
                [Boolean- 0, 1]
            </SecureBootEnabled>

            <BootDebuggingEnabled>
                [Boolean- 0, 1]
         </BootDebuggingEnabled>

            <OSKernelDebuggingEnabled>
                [Boolean-0, 1]
            </OSKernelDebuggingEnabled>
            
            <CodeIntegrityEnabled> 
                [Boolean - 0, 1]
            </CodeIntegrityEnabled>
            
            <TestSigningEnabled> 
                [Boolean - 0, 1]
            </TestSigningEnabled>
            
            <SafeMode> 
                [Boolean - 0, 1] 
            </SafeMode>
            
            <WinPE> 
                [Boolean - 0, 1] 
            </WinPE>
            
            <ELAMDriverLoaded> 
                [Boolean - 0, 1] 
            </ELAMDriverLoaded>
            
            <VSMEnabled> 
                [Boolean - 0, 1] 
            </VSMEnabled>
             
            <CIPolicyHash> 
                [INT] 
            </CIPolicyHash>

            <SBCPPolicyHash> 
                [INT] 
            </SBCPPolicyHash>

            <PCR0> 
                [INT] 
            </PCR0>
        
        </HealthCertificateProperties>

    </HealthCertificateValidationResponse>
    ```

## <a href="" id="take-policy-action"></a>**Take appropriate policy action based on evaluation results**


After the MDM server receives the verified data, the information can be used to make policy decisions by evaluating the data. Some possible actions would be:

-   Allow the device access.
-   Allow the device to access the resources, but flag the device for further investigation.
-   Prevent a device from accessing resources.

The following is a list of the data points verified by the HAS:

-   AIKPresent
-   DEPPolicy
-   BitlockerStatus
-   SecureBootEnabled
-   CodeIntegrityEnabled
-   SafeMode
-   WinPE
-   ELAMDriverLoaded
-   VSMEnabled
-   BootDebuggingEnabled
-   OSKernelDebuggingEnabled
-   TestSigningEnabled
-   BootManagerRevListVersion
-   CodeIntegrityRevListVersion
-   CIPolicyHash
-   SBCPPolicyHash
-   PCR0

Each of these are described in further detail in the following sections, along with the recommended actions to take.

<a href="" id="aikpresent"></a>**AIKPresent**  
When an Attestation Identity Key (AIK) is present on a device, it indicates that the device has an endorsement key (EK) certificate. It can be trusted more than a device that doesn’t have an EK certificate.

If AIKPresent = True (1), then allow access.

If AIKPresent = False (0), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Allow conditional access based on other data points that are present at evaluation time. For example, other attributes on the health certificate, or a devices past activities and trust history.
-   Take one of the previous actions and additionally place the device in a watch list to monitor the device more closely for potential risks.

<a href="" id="deppolicy"></a>**DEPPolicy**  
A device can be trusted more if the DEP Policy is enabled on the device.

Data Execution Prevention (DEP) Policy defines is a set of hardware and software technologies that perform additional checks on memory to help prevent malicious code from running on a system. Secure boot allows a limited list on x86/amd64 and on ARM NTOS locks it to on.

DEPPolicy can be disabled or enabled by using the following commands in WMI or a PowerShell script:

-   To disable DEP, type **bcdedit.exe /set {current} nx AlwaysOff**
-   To enable DEP, type **bcdedit.exe /set {current} nx AlwaysOn**

If DEPPolicy = 1 (On), then allow access.

If DEPPolicy = 0 (Off), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Allow conditional access based on other data points that are present at evaluation time. For example, other attributes on the health certificate, or a devices past activities and trust history.
-   Take one of the previous actions and additionally place the device in a watch list to monitor the device more closely for potential risks.

<a href="" id="bitlockerstatus"></a>**BitlockerStatus**  
When Bitlocker is on, the device is able to protect data that is stored on the drive from unauthorized access, when the system is turned off or goes to hibernation.

Windows BitLocker Drive Encryption, encrypts all data stored on the Windows operating system volume. BitLocker uses the TPM to help protect the Windows operating system and user data and helps to ensure that a computer is not tampered with, even if it is left unattended, lost, or stolen.

If the computer is equipped with a compatible TPM, BitLocker uses the TPM to lock the encryption keys that protect the data. As a result, the keys cannot be accessed until the TPM has verified the state of the computer.

If BitLockerStatus = 1 (On), then allow access.

If BitLockerStatus = 0 (Off), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Allow conditional access based on other data points that are present at evaluation time. For example, other attributes on the health certificate, or a devices past activities and trust history.
-   Take one of the previous actions and additionally place the device in a watch list to monitor the device more closely for potential risks.

<a href="" id="securebootenabled"></a>**SecureBootEnabled**  
When Secure Boot is enabled, the system is forced to boot to a factory trusted state. Also, when Secure Boot is enabled, the core components used to boot the machine must have correct cryptographic signatures that are trusted by the organization that manufactured the device. The UEFI firmware verifies this before it lets the machine start. If any files have been tampered with, breaking their signature, the system will not boot.

If SecureBootEnabled = 1 (True), then allow access.

If SecurebootEnabled = 0 (False), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Allow conditional access based on other data points that are present at evaluation time. For example, other attributes on the health certificate, or a devices past activities and trust history.
-   Take one of the previous actions and additionally place the device in a watch list to monitor the device more closely for potential risks.

<a href="" id="codeintegrityenabled"></a>**CodeIntegrityEnabled**  
When code integrity is enabled, code execution is restricted to integrity verified code.

Code integrity is a feature that validates the integrity of a driver or system file each time it is loaded into memory. Code integrity detects whether an unsigned driver or system file is being loaded into the kernel, or whether a system file has been modified by malicious software that is being run by a user account with administrator privileges.

On x64-based versions of the operating system, kernel-mode drivers must be digitally signed.

If CodeIntegrityEnabled = 1 (True), then allow access.

If CodeIntegrityEnabled = 0 (False), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Allow conditional access based on other data points that are present at evaluation time. For example, other attributes on the health certificate, or a devices past activities and trust history.
-   Take one of the previous actions and additionally place the device in a watch list to monitor the device more closely for potential risks.

<a href="" id="safemode"></a>**SafeMode**  
Safe mode is a troubleshooting option for Windows that starts your computer in a limited state. Only the basic files and drivers necessary to run Windows are started.

If SafeMode = 0 (False), then allow access.

If SafeMode = 1 (True), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Trigger a corrective action, such as informing the technical support team to contact the owner investigate the issue.

<a href="" id="winpe"></a>**WinPE**  
Windows pre-installation Environment (Windows PE) is a minimal operating system with limited services that is used to prepare a computer for Windows installation, to copy disk images from a network file server, and to initiate Windows Setup.

If WinPE = 0 (False), then allow access.

If WinPE = 1 (True), then limit access to remote resources that are required for Windows OS installation.

<a href="" id="elamdriverloaded"></a>**ELAMDriverLoaded**  
Early launch anti-malware (ELAM) provides protection for the computers in your network when they start up and before third-party drivers initialize.

If ELAMDriverLoaded = 1 (True), then allow access.

If ELAMDriverLoaded = 0 (False), then take one of the following actions that align with your enterprise policies, also accounting for whether it is a desktop or mobile device:

-   Disallow all access
-   Disallow access to HBI assets
-   Trigger a corrective action, such as informing the technical support team to contact the owner investigate the issue.

<a href="" id="vsmenabled"></a>**VSMEnabled**  
Virtual Secure Mode (VSM) is a container that protects high value assets from a compromised kernel. VSM requires about 1GB of memory – it has just enough capability to run the LSA service that is used for all authentication brokering.

VSM can be enabled by using the following command in WMI or a PowerShell script:

**Bcdedit.exe /set {current} vsmlaunchtype auto**

If ELAMDriverLoaded = 1 (True), then allow access.

If ELAMDriverLoaded = 0 (False), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Trigger a corrective action, such as informing the technical support team to contact the owner investigate the issue.

**BootDebuggingEnabled**
Boot debug enabled points to a device that is used in development & testing. Devices that are used for test and development typically are less secure: the device may run unstable code, or be configured with fewer security restrictions that is required for testing and development.

Boot debugging can be disabled or enabled by using the following commands in WMI or a PowerShell script:

-   To disable boot debugging, type **bcdedit.exe /set {current} bootdebug off**
-   To enable boot debugging, type **bcdedit.exe /set {current} bootdebug on**

If BootdebuggingEnabled = 0 (False), then allow access.

If BootDebuggingEnabled = 1 (True), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Place the device in a watch list to monitor the device more closely for potential risks.
-   Trigger a corrective action, such as enabling VSM using WMI or a Powershell script.

**OSKernelDebuggingEnabled**
OSKernelDebuggingEnabled points to a device that is used in development & testing. Devices that are used for test and development typically are less secure: they may run unstable code, or be configured with fewer security restrictions required for testing and development.

If OSKernelDebuggingEnabled = 0 (False), then allow access.

If OSKernelDebuggingEnabled = 1 (True), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI assets
-   Place the device in a watch list to monitor the device more closely for potential risks.
-   Trigger a corrective action, such as such as informing the technical support team to contact the owner investigate the issue.

**TestSigningEnabled**
When test signing is enabled, the device does not enforce signature validation during boot, and allows the unsigned drivers (such as unsigned UEFI modules) to load during boot.

Test signing can be disabled or enabled by using the following commands in WMI or a PowerShell script:

-   To disable boot debugging, type **bcdedit.exe /set {current} testsigning off**
-   To enable boot debugging, type **bcdedit.exe /set {current} testsigning on**

If TestSigningEnabled = 0 (False), then allow access.

If TestSigningEnabled = 1 (True), then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI and MBI assets
-   Place the device in a watch list to monitor the device more closely for potential risks.
-   Trigger a corrective action, such as enabling test signing using WMI or a Powershell script.

**BootManagerRevListVersion**
This attribute indicates the version of the Boot Manager that is running on the device, to allow you to track and manage the security of the boot sequence/environment.

If BootManagerRevListVersion = \[CurrentVersion\], then allow access.

If BootManagerRevListVersion != \[CurrentVersion\], then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI and MBI assets
-   Place the device in a watch list to monitor the device more closely for potential risks.
-   Trigger a corrective action, such as such as informing the technical support team to contact the owner investigate the issue.

**CodeIntegrityRevListVersion**
This attribute indicates the version of the code that is performing integrity checks during the boot sequence. Using this attribute can help you detect if the device is running the latest version of the code that performs integrity checks, or if it is exposed to security risks (revoked) and enforce an appropriate policy action.

If CodeIntegrityRevListVersion = \[CurrentVersion\], then allow access.

If CodeIntegrityRevListVersion != \[CurrentVersion\], then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Disallow access to HBI and MBI assets
-   Place the device in a watch list to monitor the device more closely for potential risks.
-   Trigger a corrective action, such as such as informing the technical support team to contact the owner investigate the issue.

**CIPolicyHash**
This attribute indicates the Code Integrity policy that is controlling the security of the boot environment.

If CIPolicyHash is not present, or is an accepted (whitelisted) value, then allow access.

If CIPolicyHash is present and is not a whitelisted value, then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Place the device in a watch list to monitor the device more closely for potential risks.

**SBCPPolicyHash**
SBCPPolicyHash is the Hash of a custom Secure Boot Configuration Policy (SBCP) .

If a device is using the default policy (that is embedded in bootmgr) no hash is added.

If a device is using the "Custom" policy hash of the custom policy, it will be measured and added to the TPM logs.

If SBCPPolicyHash is not present, or is an accepted (whitelisted) value, then allow access.

If SBCPPolicyHash is present and is not a whitelisted value, then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Place the device in a watch list to monitor the device more closely for potential risks.

**PCR0**
The measurement that is captured in PCR\[0\] typically represents a consistent view of the Host Platform between boot cycles. It contains a measurement of components that are provided by the host platform manufacturer.

Enterprise managers can create a whitelist of trusted PCR\[0\] values, compare the PCR\[0\] value of the managed devices (the value that is verified and reported by HAS) with the whitelist, and then make a trust decision based on the result of the comparison.

If your enterprise does not have a whitelist of accepted PCR\[0\] values, then take no action.

If PCR\[0\] equals an accepted whitelisted value, then allow access.

If PCR\[0\] does not equal any accepted whitelisted value, then take one of the following actions that align with your enterprise policies:

-   Disallow all access
-   Direct the device to an enterprise honeypot, to further monitor the device's activities.

## **Additional Examples**


The following are additional code examples to assist you in integrating Health Attestation into your enterprise.

## Health certificate request


``` syntax
<HealthCertificateRequest ProtocolVersion="1" xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/request/v1">
  <Claims>AAECAwQFBgcICQoLDA0ODw==</Claims>
  <AIKCertificate>AAECAwQFBgcICQoLDA0ODw==</AIKCertificate>
</HealthCertificateRequest>
```

## Health certificate response


``` syntax
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema id="HealthCertificateResponse"
           xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/response/v1"
xmlns:xs="http://www.w3.org/2001/XMLSchema"           targetNamespace="http://schemas.microsoft.com/windows/security/healthcertificate/response/v1"
elementFormDefault="qualified">

    <xs:element name="HealthCertificateResponse" type="HealthCertificateResponse_T"/>

    <xs:complexType name="ResponseCommon_T">
        <xs:attribute name="ErrorCode" type="xs:int" use="required"/>
        <xs:attribute name="ErrorMessage" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:group name="HealthCertificateResponseData">
        <xs:annotation>
            <xs:documentation>Health certificate response data</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="HealthCertificateBlob"  minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                      The base 64 encoded Health Certificate blob.
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:base64Binary">
                        <xs:minLength value="1"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
        </xs:sequence>
    </xs:group>

    <xs:complexType name="HealthCertificateResponse_T" >
        <xs:complexContent>
            <xs:extension base="ResponseCommon_T">
                <xs:group ref="HealthCertificateResponseData" minOccurs="0"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
</xs:schema>
```

## Health certificate response example


``` syntax
<HealthCertificateResponse ErrorCode="1" ErrorMessage="ErrorMessage1" xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/response/v1">
  <HealthCertificateBlob>AAECAwQFBgcICQoLDA0ODw==</HealthCertificateBlob>
</HealthCertificateResponse>
```

## Health state validation request


``` syntax
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1"
targetNamespace="http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1"
elementFormDefault="qualified">

  <xs:element name="HealthCertificateValidationRequest"   type="HealthCertificateValidationRequest_T"/>

  <xs:complexType name="HealthCertificateValidationRequest_T">
    <xs:annotation>
      <xs:documentation>A request for Health Certificate validation </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Nonce"                    type="xs:hexBinary"/>
      <xs:element name="Claims"                   type="xs:base64Binary"/>
      <xs:element name="HealthCertificateBlob"    type="xs:base64Binary"/>
    </xs:sequence>
    <xs:attribute name="ProtocolVersion" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:int">
          <xs:minInclusive value="1"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
</xs:schema>
```

## Health state validation request example


``` syntax
<HealthCertificateValidationRequest ProtocolVersion="1" xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/validation/request/v1">
  <Nonce>0FB7</Nonce>
  <Claims>AAECAwQFBgcICQoLDA0ODw==</Claims>
  <HealthCertificateBlob>AAECAwQFBgcICQoLDA0ODw==</HealthCertificateBlob>
</HealthCertificateValidationRequest>
```

## Health state validation response


``` syntax
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://schemas.microsoft.com/windows/security/healthcertificate/validation/response/v1"
           targetNamespace="http://schemas.microsoft.com/windows/security/healthcertificate/validation/response/v1"
           elementFormDefault="qualified">

    <xs:element name="HealthCertificateValidationResponse" type="HealthCertificateValidationResponse_T"/>

    <xs:complexType name="ResponseCommon_T">
        <xs:attribute name="ErrorCode" type="xs:int" use="required"/>
        <xs:attribute name="ErrorMessage" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="HealthCertificatePublicProperties_T">
        <xs:annotation>
            <xs:documentation>Health certificate non machine identifiable properties </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="Issued"                       type="xs:dateTime"/>
            <xs:element name="ResetCount"                   type="xs:unsignedInt"/>
            <xs:element name="RestartCount"                 type="xs:unsignedInt"/>
            <xs:element name="DEPPolicy"                    type="xs:unsignedInt"/>
            <xs:element name="BitlockerStatus"              type="xs:unsignedInt"/>
            <xs:element name="SecureBootEnabled"            type="Boolean_T"/>
            <xs:element name="BootDebuggingEnabled"         type="Boolean_T"/>
            <xs:element name="OSKernelDebuggingEnabled"     type="Boolean_T"/>
            <xs:element name="CodeIntegrityEnabled"         type="Boolean_T"/>
            <xs:element name="TestSigningEnabled"           type="Boolean_T"/>
            <xs:element name="SafeMode"                     type="Boolean_T"/>
            <xs:element name="WinPE"                        type="Boolean_T"/>
            <xs:element name="ELAMDriverLoaded"             type="Boolean_T"/>
            <xs:element name="VSMEnabled"                   type="Boolean_T"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="HealthStatusProperties_T">
        <xs:annotation>
            <xs:documentation>Health certificate validation response data</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="RestartCount"                  type="xs:unsignedInt"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="HealthCertificateValidationResponse_T" >
        <xs:annotation>
            <xs:documentation>Health certificate validation response </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ResponseCommon_T">
                <xs:sequence>
                    <!--Optional element, present only when the certificate can be verified and decrypted-->
                    <xs:element name="HealthCertificateProperties"  type="HealthCertificatePublicProperties_T"  minOccurs="0"/>
                    <!--Optional element, present only when the reason for a validation failure is a mismatch between the 
                    current health state and the certificate health state-->
                    <xs:element name="HealthStatusProperties"       type="HealthStatusProperties_T"             minOccurs="0"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
```

## Related topics


[Configuration service provider reference](configuration-service-provider-reference.md)

 

 

10/10/2016




